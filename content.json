{"meta":{"title":"My blog","subtitle":"","description":"","author":"Ciallo-Ani","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"插件更新日志","slug":"plugin-update-log","date":"2022-01-03T19:29:07.000Z","updated":"2022-01-03T20:07:08.461Z","comments":true,"path":"2022/01/04/plugin-update-log/","link":"","permalink":"http://example.com/2022/01/04/plugin-update-log/","excerpt":"","text":"TODO 区域限速 重写zones(参考momentum) TAS(low p) Segment关卡(low p) 搬运fuckzones(low p) 2022/1/2 已修复 练习模式出起点区域不应该显示prestrafe 练习模式的穿墙不应该暂停 回放菜单选择完毕后不应该重新打开菜单 新功能 穿墙速度 2022/1/3 已修复 可能导致无法获取steamid的问题. Github -&gt; f975906f 编辑区域时，菜单换成分页 新功能 添加油漆枪到自己的仓库中 优化 zones代码 misc代码 强调自己是个滑翔插件, 不要用bhop标准衡量. Github -&gt; f230016f","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"面试题解析：大厂面试必问之—HashMap","slug":"hashMap","date":"2021-12-25T08:12:52.000Z","updated":"2021-12-27T09:08:22.199Z","comments":true,"path":"2021/12/25/hashMap/","link":"","permalink":"http://example.com/2021/12/25/hashMap/","excerpt":"","text":"大佬的hashMap的面试总结1.说说你对hash算法的理解 答：嗯，hashMap基本概述就量把任意长度的输入通过一个hash算法之后映射成固定长度的输出。 追问1：hash算法任意长度的输入 转化为了 固定长度的输出，会不会有问题呢？ 答：这个肯定会有问题的，在程序中可能碰到两个value值经过hash算法之后算法同样的hash值，也就会发生hash冲突。 追问2：hash冲突能避免么？ 答：这个理论是没法避免的，就类比咱一共有6根黄黄的香蕉，但是咱一个才有5个盒子，就是最终一定会有一个盒子里的数量是大于1的，所以，hash冲突没有办法避免，只能尽量减少或者避免冲突的产生。比如加盒子或者放时更均衡等策略。 追问3：你认为好的hash算法，应该考虑点有哪些呢？ ​ 答：首先这个hash算法，它一定效率得高，要做到长文本也能高效计算出hash值嘛，这二点就是hash值不能让它逆推出原文吧；两次输入，只要有一点不同，它也得保证这个hash值是不同的。其次，就是尽可能的要分散吧，因为，在table中slot中slot大总会发都处于空闲状的，要尽可能降低hash冲突。 2.HashMap中存储数据的结构是什么样的呢？ 答：JDK1.7： 数组 + 链表； JDK1.8：数组 + 链表 + 红黑树，每个数据块是一个Node结构，Node结构中有key、value、next、hash这四个属性。next属性就是发生hash冲突的时候，当前桶位中node与冲突的node连成一个链表要用的属性，即当前节点的下一个节点。 3.创建HashMap时，不指定散列表数组长度，初始长度是多少呢？ 答：默认是16 在JDK 8中，关于默认容量的定义为：static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //16 ，其故意把16写成1&lt;&lt;4，就是提醒开发者，这个地方要是2的幂。 追问1：为啥用位运算呢？直接写16不好么？ ​ 答：这样是为了位运算的方便，位与运算比算数计算的效率高了很多，之所以选择16，是为了服务将Key映射到index的算法。 追问2：为啥用16不用别的呢？ 答：因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。这个值既不能太小，也不能太大。太小了就有可能频繁发生扩容，影响效率，太大了又浪费空间，不划算。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了实现均匀分布。 追问3：散列表是new HashMap() 时创建的么？ ​ 答：不是，是在第一次put时创建的 4.默认负载因子是多少呢，并且这个负载因子有什么作用？ 答：默认是…默认负载因子0.75，就是75%，负载因子它的作用就是计算扩容阈值用的，比如使用无参构造方法创建的hashmap对象，它默认情况下扩容阈值就 16*0.75 = 12 5.链表转化为红黑树，需要达到什么条件呢？ 答：链表转红黑树，主要是有两个指标，1）是链表长度达到8，这有个指标就是当前散列表数组长度它已经达到64。否则的话，就算slot内部链表长度到了8，它也不会链转树，它仅仅会发生一次resize，散列表扩容。 6.Node对象内部的hash字段，这个hash值是key对象的hashcode()返回值么？ 答：不是的 追问1：这个hash值是怎么得到呢？ 答：这个hash值是key.hashcode二次加工得到的。加工原则是：key的hashcode 高16位 ^ 低16位，得到的一个新值。 追问2：hash字段为什么采用高低位异或？ ​ 答：主要为了优化hash算法，因为hashmap内部散列表，它大多数场景下，它不会特别大。也就是说这个[table.length - 1] 得到的这个二进制数，实际有效位很有限，一般都在（低）16位以内，这样的话，key的hash值高16位就等于完全浪费了，没起到作用。所以，node的hash字段才采用了 高16位 异或 低16位 这种方式来搞它。 7.HashMap put 写数据的具体流程，尽可能的详细点！ 答： 主要为4种情况：前面这个，寻址算法是一样的，都是根据key的hashcode 经过 高低位 异或 之后的值，然后再 按位与 &amp; （table.length -1)，得到一个槽位下标，然后根据这个槽内状况，状况不同，情况也不同，大概就是4种状态， 1）是slot == null，直接占用slot就可以了，然后把当前put方法传进来的key和value包状成一个Node 对象，放到这个slot中就可以了 2）slot != null 并且 它引用的node 还没有链化；需要对比一下，node的key 与当前put 对象的key 是否完全相等；如果完全相等的话，这个操作就是replace操作，就是替换操作，把那个新的value替换当前slot -&gt; node.value 就可以了；否则的话，这次put操作就是一个正儿八经的hash冲突了，slot-&gt;node 后面追加一个node就可以了，采用尾插法。 3）就是slot 内的node已经链化了；这种情况和第二种情况处理很相似，首先也是迭代查找node，看看链表上的元素的key，与当前传来的key是不是完全一致。如果一致的话，还是repleace操作，替换当前node.value，否则的话就是我们迭代到链表尾节点也没有匹配到完全一致的node，把put数据包装成node追加到链表尾部；这块还没完，还需要再检查一下当前链表长度，有没有达到树化阈值，如果达到阈值的话，就调用一个树化方法，树化操作都在这个方法里完成 4）就是冲突很严重的情况下，就是那个链已经转化成红黑树了 8.红黑树的写入操作，是怎么找到父节点的，找父节点流程？ 答：说清楚红黑树，首先说清楚TreeNode，TreeNode它就是继承Node结构，在Node基础上加了几个字段，分别指向父节点parent，然后指向左子节点left，还有指向右子节点的right，然后还有表示颜色red/black，这个就是TreeNode的基本结构 红黑树的插入操作：首先是找到一个合适的插入点，就是找到插入节点的父节点，然后这个红黑树它又满足二叉树的所有排序特性…(满足二叉排序树的所有特性)，这个找父节点的操作和二叉树是完全一致的。二叉查找树，左子节点小于当前节点，右子节点大于当前节点，然后每一次向下查找一层就可以排除掉一半的数据，插入效率在log(N) 查找的过程也是分情况的，第一种情况就是一直向下探测，直到查询到左子树或者右子树为null，说明整个树中，它没有发现node.key与当前put key 一致的这个TreeNode。此时探测节点就是插入父节点所在了；然后是当前插入节点插入到父节点的左子树或者右子树，就完事了，然后，根据这个插入节点的hash值和父节点的hash值大小决定左右的，插入会打码平衡，还需要一个红黑树的平衡算法。 第二种情况就是根节点向下探测过程中，发现这个TreeNode.key 与当前 put.key 完全一致。说明它也是一次repleace操作。 9.TreeNode数据结构，简单说下。 答：继承node节点 1static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links 父节点 TreeNode&lt;K,V&gt; left;// 左孩子 TreeNode&lt;K,V&gt; right;// 右孩子 TreeNode&lt;K,V&gt; prev; //当前节点 needed to unlink next upon deletion boolean red;//颜色，红/黑 10.红黑树的原则有哪些呢？ 答： 每个节点颜色不是黑色，就是红色 根节点是黑色的 如果一个节点是红色，那么它的两个子节点就是黑色的(没有连续的红节点) 对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目黑色节点 11.JDK8 hashmap为什么引入红黑树？解决什么问题？ 答：在JDK1.6，JDK1.7中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。在jdk1.8版本后，java对HashMap做了改进，在链表长度大于8的时候，将后面的数据存在红黑树中，以加快检索速度。 JDK1.8HashMap的红黑树是这样解决的： ​ 如果某个桶中的记录过大的话（当前是TREEIFY_THRESHOLD = 8），HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好 ​ 它是如何工作的？前面产生冲突的那些KEY对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后HashMap开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。 追问1：为什么是红黑树？为什么不直接采用红黑树还要用链表？1、因为红黑树需要进行左旋，右旋操作， 而单链表不需要， 如果元素小于8个，查询成本高，新增成本低 如果元素大于8个，查询成本低，新增成本高 追问2：为什么hash冲突后性能变低了？【送分题】 ​ 需要去链表或者红黑树中循环去找元素，不管是哪两种都会使怪胎变低。 12.hashmap 什么情况下会触发扩容呢？ 答：在写数据之后会触发扩容，可能会触发扩容。hashmap结构内，我记得有个记录当前数据量的字段，这个数据量字段达到扩容阈值的话，下一个写入的对象是在列表才会触发扩容 追问1：触发扩容后，会扩容多大呢？算法是什么？ 答：因为table 数组长度必须是2的次方数嘛，扩容其实，每次都是按照上一次的tableSize位移运算得到的。就是做一次左移1位运算，假设当前tableSize是16的话，16 &lt;&lt; 1 == 32 追问2：为什么采用位移运算，不是直接*2？ 答：主要是因为性能，因为cpu毕竟它不支持乘法运算，所有乘法运算它最终都是在指令层面转化为加法实现的。效率很低，如果用位运算的话对cpu来说就非常简洁高效 13.hashmap扩容后，老表的数据怎么迁移到扩容后的表的呢？ 迁移其实就是，每个桶位推进迁移，就是一个桶位一个桶位的处理；主要还是看当前处理桶位的数据状态吧 4种状态吧 1）slot存储t是null， 2）slot存储的是个node（没有链化） 3）slot存储的是个链表 4）slot存储的是一个红黑树根节点TreeNode对象 这4种每种状态迁移者不一样，判断走不同的逻辑如下 1）不用处理 2）它的next节点是null，根据新表的tableSize计算出它在新表的位置，然后存放 过去就可以了 3）它的next节点不是null，链表。拆成两个链表，高位链和低位链 ​ 高位链：高位不一定相同，有的node高位可能 是0，有的node高位可能是1，这块对应的node迁移到新表中，它所存放 的slot位置也是不一样的。那高位链，因为高位链是1，所以说存储到扩容，就是到新了之后。。是老表的位置 +老表的size ​ 如: 老表table是16，数据存放在老表（下标）8的位置，那存储扩容后，表的位置就是8+16就是24。 ​ 低位链：指的是老表的tablesize-1转化出来的二进制数的有效位，低位链因为高位是0，所以说迁移到node新表的时候，这个slot下标和老的是一样的。 ​ 如：table数据长度是16，16-1是15，然后15转化出来的二进制数就是1111 ， 说明你们是低四位，高位是5位 4）迁移数据发现该slot是颗红黑树，怎么处理呢？ 红黑树节点对象，这个TreeNode结构啊，依然保留了这个next字段， 它内部还维护一个链表，但是增强删除节点时还需要维护， 链表作用是啥呢 方便split拆分这个红黑树时去用的，其实就是普通 没啥区别，就是根据高低位，拆分高低位链， 高位链这个数据：最终要存放到新表的，下标 就是老表的这个位置+老表的数组长度，然后计算出来的这个位置 。 低位链这个数据：存放益 和老表是同一个位置。 不同的点。是拆分出来的表，需要看一下它的长度。 1）如果 这个长度是&lt;=6把TreeNode转化为普通的node链表，然后存放到这个扩容后的新表中就可以了 2）如果这个长期是&gt;6的话，那么需要重建红黑树","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://example.com/tags/Data-Structure/"}]},{"title":"MYSQL—数据类型和常用函数","slug":"mysql","date":"2021-12-23T04:11:25.000Z","updated":"2021-12-27T08:47:29.712Z","comments":true,"path":"2021/12/23/mysql/","link":"","permalink":"http://example.com/2021/12/23/mysql/","excerpt":"","text":"数据类型介绍MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 1. 数值类型 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 ———————————————— 2. 日期和时间类型 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 3. 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 常用函数 mysql内置函数列表可以从mysql官方文档查询，这里仅分类简单介绍一些可能会用到的函数。 1. 数学函数$$abs(x) pi() mod(x,y)：余数 sqrt(x)：开平方根 ceil(x)或者ceiling(x) rand(),rand(N):返回0-1间的浮点数，使用不同的seed N可以获得不同的随机数 round(x, D)：四舍五入保留D位小数，D默认为0， 可以为负数， 如round(19, -1)返回20 truncate(x, D):截断至保留D位小数，D可以为负数， 如trancate(19,-1)返回10 sign(x): 返回x的符号，正负零分别返回1， -1， 0 pow(x,y)或者power(x,y) exp(x)：e^x log(x)：自然对数 log10(x)：以10为底的对数 radians(x):角度换弧度 degrees(x):弧度换角度 sin(x)和asin(x): cos(x)和acos(x): tan(x)和atan(x): cot(x):$$ 2. 字符串函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455char_length(str):返回str所包含的字符数，一个多字节字符算一个字符length(str): 返回字符串的字节长度，如utf8中，一个汉字3字节，数字和字母算一个字节concat(s1, s1, ...): 返回连接参数产生的字符串concat_ws(x, s1, s2, ...): 使用连接符x连接其他参数产生的字符串INSERT(str,pos,len,newstr):返回str,其起始于pos，长度为len的子串被newstr取代。\\1. 若pos不在str范围内，则返回原字符串str\\2. 若str中从pos开始的子串不足len,则将从pos开始的剩余字符用newstr取代\\3. 计算pos时从1开始，若pos=3,则从第3个字符开始替换lower（str)或者lcase(str):upper(str)或者ucase(str):left(s,n):返回字符串s最左边n个字符right(s,n): 返回字符串最右边n个字符lpad(s1, len, s2): 用s2在s1左边填充至长度为len, 若s1的长度大于len,则截断字符串s1至长度len返回rpad(s1, len, s2):ltrim(s):删除s左侧空格字符rtrim(s):TRIM([&#123;BOTH | LEADING | TRAILING&#125; [remstr] FROM] str)或TRIM([remstr FROM] str)：从str中删除remstr, remstr默认为空白字符REPEAT(str,count)：返回str重复count次得到的新字符串REPLACE(str,from_str,to_str)： 将str中的from_str全部替换成to_strSPACE(N):返回长度为N的空白字符串STRCMP(str1,str2):若str1和str2相同，返回0， 若str1小于str2, 返回-1， 否则返回1.SUBSTRING(str,pos), SUBSTRING(str FROM pos), SUBSTRING(str,pos,len), SUBSTRING(str FROM pos FOR len),MID(str,pos,len): 获取特定位置，特定长度的子字符串LOCATE(substr,str), LOCATE(substr,str,pos),INSTR(str,substr),POSITION(substr IN str): 返回字符串中特定子串的位置，注意这里INSTR与其他函数的参数位置是相反的REVERSE(str)ELT(N,str1,str2,str3,...)：返回参数strN, 若N大于str参数个数，则返回NULLFIELD(str,str1,str2,str3,...): 返回str在后面的str列表中第一次出现的位置，若找不到str或者str为NULL, 则返回0FIND_IN_SET(str,strlist)：strlist是由&#x27;,&#x27;分隔的字符串，若str不在strlist或者strlist为空字符串，则返回0；若任意一个参数为NULL则返回ＮＵＬＬMAKE_SET(bits,str1,str2,...): 由bits的作为位图来选取strN参数，选中的参数用&#x27;,&#x27;连接后返回 3. 日期和时间函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CURDATE(), CURRENT_DATE, CURRENT_DATE():用于获取当前日期，格式为&#x27;YYYY-MM-DD&#x27;; 若+0则返回YYYYMMDDUTC_DATE, UTC_DATE():返回当前世界标准时间CURTIME([fsp]), CURRENT_TIME, CURRENT_TIME([fsp]): 用于获取当前时间， 格式为&#x27;HH:MM:SS&#x27; 若+0则返回 HHMMSSUTC_TIME, UTC_TIME([fsp])CURRENT_TIMESTAMP, CURRENT_TIMESTAMP([fsp]), LOCALTIME, LOCALTIME([fsp]), SYSDATE([fsp]), NOW([fsp]): 用于获取当前的时间日期，格式为&#x27;YYYY-MM-DD HH:MM:SS&#x27;，若+0则返回YYYYMMDDHHMMSSUTC_TIMESTAMP, UTC_TIMESTAMP([fsp])UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date)：返回一个unix时间戳（&#x27;1970-01-01 00:00:00&#x27; UTC至今或者date的秒数），这实际上是从字符串到整数的一个转化过程FROM_UNIXTIME(unix_timestamp), FROM_UNIXTIME(unix_timestamp,format)：从时间戳返回&#x27;YYYY-MM-DD HH:MM:SS&#x27; 或者YYYYMMDDHHMMSS，加入format后根据所需的format显示。MONTH(date)MONTHNAME(date)DAYNAME(date)DAY(date)，DAYOFMONTH(date)：1-31或者0DAYOFWEEK(date)：1-7==&gt;星期天-星期六DAYOFYEAR(date)：1-365（366）WEEK(date[,mode])：判断是一年的第几周，如果1-1所在周在新的一年多于4天，则将其定为第一周；否则将其定为上一年的最后一周。mode是用来人为定义一周从星期几开始。WEEKOFYEAR(date)：类似week(date,3)，从周一开始计算一周。QUARTER(date)：返回1-4HOUR(time)：返回时间中的小时数，可以大于24MINUTE(time)：SECOND(time)：EXTRACT(unit FROM date)：提取日期时间中的要素- - - - ​```SELECT EXTRACT(YEAR FROM &#x27;2009-07-02&#x27;); ##2009SELECT EXTRACT(YEAR_MONTH FROM &#x27;2009-07-02 01:02:03&#x27;);##200907SELECT EXTRACT(DAY_MINUTE FROM &#x27;2009-07-02 01:02:03&#x27;);##20102SELECT EXTRACT(MICROSECOND FROM &#x27;2003-01-02 10:30:00.000123&#x27;);##123​```TIME_TO_SEC(time)SEC_TO_TIME(seconds)TO_DAYS(date): 从第0年开始的天数TO_SECNDS(expr)：从第0年开始的秒数ADDDATE(date,INTERVAL expr unit), ADDDATE(expr,days),DATE_ADD(date,INTERVAL expr unit)DATE_SUB(date,INTERVAL expr unit), DATE_SUB(date,INTERVAL expr unit)ADDTIME(expr1,expr2)SUBTIME(expr1,expr2)- - ​```SELECT ADDTIME(&#x27;2007-12-31 23:59:59.999999&#x27;, &#x27;1 1:1:1.000002&#x27;);##&#x27;2008-01-02 01:01:01.000001&#x27;SELECT ADDTIME(&#x27;01:00:00.999999&#x27;, &#x27;02:00:00.999998&#x27;);##&#x27;03:00:01.999997&#x27;​```注意：时间日期的加减也可以直接用+/-来进行- - - - - ​```date + INTERVAL expr unitdate - INTERVAL expr unitSELECT &#x27;2008-12-31 23:59:59&#x27; + INTERVAL 1 SECOND;##&#x27;2009-01-01 00:00:00&#x27;SELECT INTERVAL 1 DAY + &#x27;2008-12-31&#x27;;##&#x27;2009-01-01&#x27;SELECT &#x27;2005-01-01&#x27; - INTERVAL 1 SECOND;##&#x27;2004-12-31 23:59:59&#x27; ​```DATE_FORMAT(date,format):DATEDIFF(expr1,expr2):返回相差的天数TIMEDIFF(expr1,expr2)：返回相隔的时间 4. 条件判断函数 12345678910111213IF(expr1,expr2,expr3)：如果expr1不为0或者NULL,则返回expr2的值，否则返回expr3的值IFNULL(expr1,expr2)：如果expr1不为NULL,返回expr1,否则返回expr2NULLIF(expr1,expr2): 如果expr1=expr2则返回NULL, 否则返回expr2CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END当compare_value=value时返回resultCASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END当condition为TRUE时返回result 1SELECT CASE 1 WHEN 1 THEN ‘one’WHEN 2 THEN ‘two’ ELSE ‘more’ END;##‘one’SELECT CASE WHEN 1&gt;0 THEN ‘true’ ELSE ‘false’ END;##‘true’SELECT CASE BINARY ‘B’WHEN ‘a’ THEN 1 WHEN ‘b’ THEN 2 END;##NULL 5. 系统信息函数 12345678910111213VERSION():返回mysql服务器的版本，是utf8编码的字符串CONNECTION_ID()：显示连接号（连接的线程号）DATABASE()，SCHEMA()：显示当前使用的数据库SESSION_USER(), SYSTEM_USER(), USER(), CURRENT_USER, CURRENT_USER():返回当前的用户名@主机，utf8编码字符串CHARSET(str)COLLATION(str)LAST_INSERT_ID()：自动返回最后一个insert或者update查询， 为auto_increment列设置的第一个发生的值 6. 加密和压缩函数 12345678910111213141516171819202122232425262728293031323334353637383940414243PASSWORD(str):这个函数的输出与变量old_password有关。old_password 在mysql5.6中默认为0。old_password=1时， password(str)的效果与old_password(str)相同，由于其不够安全已经弃用（5.6.5以后）。old_password=2时，在生成哈希密码时会随机加盐。MD5(str):计算MD5 128位校验和，返回32位16进制数构成的字符串，当str为NULL时返回NULL。可以用作哈希密码SHA1(str), SHA(str)：计算160位校验和，返回40位16进制数构成的字符串，当str为NULL时返回NULL。SHA2(str, hash_length)：计算SHA-2系列的哈希方法(SHA-224, SHA-256, SHA-384, and SHA-512). 第一个参数为待校验字符串，第二个参数为结果的位数（224， 256， 384， 512）ENCRYPT(str[,salt]): 用unix crypt()来加密str. salt至少要有两位字符，否则会返回NULL。若未指定salt参数，则会随机添加salt。ECODE(crypt_str,pass_str):解密crypt_str, pass_str用作密码ENCODE(str,pass_str)：用pass_str作为密码加密strDES_ENCRYPT(str[,&#123;key_num|key_str&#125;])：用Triple-DES算法编码str， 这个函数只有在mysql配置成支持ssl时才可用。DES_DECRYPT(crypt_str[,key_str])AES_ENCRYPT(str,key_str[,init_vector])AES_DECRYPT(crypt_str,key_str[,init_vector])COMPRESS(string_to_compress)：返回二进制码UNCOMPRESS(string_to_uncompress) 7. 聚合函数 若在没使用group by时使用聚合函数，相当于把所有的行都归于一组来进行处理。除非特殊说明，一般聚合函数会忽略掉NULL. 123456789101112131415161718192021222324252627282930313233343536373839AVG([DISTINCT] expr): 返回expr的平均值，distinct选项用于忽略重复值COUNT([DISTINCT] expr)：返回select中expr的非0值个数，返回值为bigint类型group_concat:连接组内的非空值，若无非空值，则返回NULLGROUP_CONCAT([DISTINCT] expr [,expr …][ ORDER BY &#123;unsigned_integer | col_name | expr&#125;[ASC | DESC] [,col_name …]MAX([DISTINCT] expr)MIN([DISTINCT] expr)SUM([DISTINCT] expr)VAR_POP(expr)VARIANCE(expr)：同VAR_POP(expr)，但是这是标准sql的一个扩展函数VAR_SAMP(expr)STD(expr): 这是标准sql的一个扩展函数STDDEV(expr)：这个函数是为了跟oracle兼容而设置的STDDEV_POP(expr)：这个是sql标准函数STDDEV_SAMP(expr)：样本标准差 8. 格式或类型转化函数 1234567891011FORMAT(X,D[,locale])：将数字X转化成&#x27;#,###,###.##&#x27;格式，D为保留的小数位数CONV(N,from_base,to_base)：改变数字N的进制，返回值为该进制下的数字构成的字符串INET_ATON(expr)：ip字符串转数字INET_NTOA(expr)：数字转ip字符串CAST(expr AS type)：转换数据类型CONVERT(expr,type), CONVERT(expr USING transcoding_name)：type可以为BINARY[(N)]，CHAR[(N)]，DATE，DATETIME， DECIMAL[(M[,D])]，DECIMAL[(M[,D])]，TIME，UNSIGNED [INTEGER]等等。transcoding_name如utf8等等","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://example.com/tags/Data-Structure/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"笔记 (指针操作2D array)","slug":"ptrIn2DArr","date":"2021-12-13T06:18:21.000Z","updated":"2021-12-13T07:45:43.241Z","comments":true,"path":"2021/12/13/ptrIn2DArr/","link":"","permalink":"http://example.com/2021/12/13/ptrIn2DArr/","excerpt":"","text":"有时需要二维数组传参，但实际上是二级指针传参1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;math.h&gt;using std::cin;using std::cout;void ShowMartix(int **arr, const int &amp;len)&#123; for(int i = 0; i &lt; len; i++) &#123; for(int j = 0; j &lt; len; j++) &#123; cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;void CutMartix(int **arr, const int &amp;len)&#123; for(int i = 0; i &lt; len/2; i++) &#123; for(int j = 0; j &lt; len/2; j++) &#123; arr[i][j] = 0; &#125; &#125; cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123; int n; cin &gt;&gt; n; int len = pow(2, n); int matrix[len][len]; int **p = nullptr; p = (int **)malloc(sizeof(int *) *len); for (int i = 0; i &lt; len*len; i++) &#123; *((int*)matrix + i) = 1; &#125; for(int i = 0; i &lt; len; i ++) &#123; p[i] = matrix[i]; &#125; ShowMartix(p, len); CutMartix(p, len); ShowMartix(p, len); free(p); return 0;&#125;","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"1970-12-31T16:00:00.000Z","updated":"2021-12-13T03:53:08.936Z","comments":true,"path":"1971/01/01/hello-world/","link":"","permalink":"http://example.com/1971/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://example.com/tags/Data-Structure/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"}]}